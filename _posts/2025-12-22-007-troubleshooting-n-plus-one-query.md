---
title: "페이지 로딩 지연의 원인, SQL 기반 N + 1 문제와 조회 전략 개선"
slug: troubleshooting-n-plus-one-query
description: >-
  더미 데이터가 많지 않은 상황에서도 특정 페이지의 로딩이 느려지는 문제가 발생했습니다.
  원인을 추적한 결과 SQL 기반 N + 1 문제를 확인했고,
  Application-side Join(Bulk Query 기반) 방식으로 조회 전략을 개선한 트러블슈팅 경험을 정리했습니다.
author: inttype
date: 2025-12-22 23:22:00 +0900
categories: [Development, Database]
tags: [n+1, sql, query, performance, troubleshooting, bulk-query, application-side-join]
pin: false
---

## N + 1 문제로 인한 성능 저하 경험과 해결 과정

개발 중 특정 페이지가 다른 페이지에 비해 유독 로딩이 늦어지는 현상을 발견했습니다.  
더미 데이터가 몇 개밖에 없는 상황이었기 때문에 성능 저하가 발생할 이유가 없다고 판단했고,  
원인을 추적하던 중 **N + 1 문제**에 해당한다는 것을 확인했습니다.

### 문제 상황

해당 기능은 다음과 같은 방식으로 구현되어 있었습니다.

1. 사용자의 모든 항목을 조회 (1번)
2. 각 항목에 대해 반복문을 돌며  
   - 사용 횟수 조회 (N번)
   - 제출 타입 조회 (N번)

즉, 전체 쿼리 구조는 **1 + 2N** 형태였습니다.  
예를 들어 항목이 50개라면 `1 + (50 × 2) = 101`번의 쿼리가 실행되며,  
처음에는 괜찮았지만 더미 데이터가 늘어남에 따라 페이지 로딩 속도가 눈에 띄게 느려졌습니다.

---

## 해결 방법: Application-side Join (Bulk Query 기반)

이를 해결하기 위해 쿼리 방식을 **일괄 조회(Bulk Query)** 중심으로 재설계했습니다.

### 개선된 조회 방식

1. 사용자의 모든 항목 조회 (1번)
2. 조회된 항목 ID 목록을 기반으로  
   - 모든 항목의 제출 타입을 한 번에 조회 (`IN` 절 사용, 1번)
   - 모든 항목의 사용 횟수를 한 번에 조회 (`IN` 절 + `GROUP BY`, 1번)

총 **3번의 쿼리**로 필요한 데이터를 모두 조회한 뒤,  
애플리케이션 메모리에서 **ID 기준으로 매핑하여 조립**했습니다.

이로 인해 현재 요구사항 기준에서는  
`항목 목록 + 타입 조회 + 사용 횟수 조회`로 쿼리 수가 고정되었고,  
항목 수에 비례한 쿼리 증가가 발생하지 않게 되었습니다.

---

## JPA의 N + 1 문제는 무엇이 다른가?

JPA에서도 N + 1 문제는 자주 언급되지만,  
이번 사례와는 **발생 원인에 차이**가 있습니다.

JPA의 N + 1 문제는  
**명시적으로 반복 쿼리를 작성하지 않았음에도**,  
객체 그래프를 탐색하는 과정에서 프록시 초기화(Lazy Loading)로 인해  
의도치 않게 추가 쿼리가 발생한다는 점이 특징입니다.

개발자는 단순히 연관 객체의 getter를 호출했을 뿐인데,  
JPA가 내부적으로 쿼리를 실행하면서  
프레임워크 특성상 N + 1 문제가 발생하는 경우가 많습니다.

---

## SQL을 직접 작성했는데도 왜 사전에 방지하지 못했을까?

초기 MVP 단계에서는 **개발 생산성과 코드 재사용성**을 최우선으로 고려했습니다.

이미 검증된 **단건 조회용 메소드**를 목록 조회에서도 재사용함으로써  
비즈니스 로직의 파편화를 막고, 빠르게 기능을 구현하고자 했습니다.

당시에는 데이터 양이 적어 성능 영향이 미미하다고 판단했지만,  
더미 데이터가 늘어나면서 N + 1 문제가 가시화되었고  
이를 해결하기 위해 **Application-side Join (Bulk Query 기반)** 패턴을 도입하게 되었습니다.

---

## JOIN 대신 Application-side Join을 선택한 이유

N + 1 문제를 해결하기 위해 단순히 `LEFT JOIN`을 사용하는 방법도 고려할 수 있었습니다.  
하지만 항목(1) : 제출 타입(N) : 사용 이력(M) 구조가 얽혀 있어  
**Cartesian Product(카테시안 곱)** 문제가 발생할 우려가 있었습니다.

특히 사용 이력처럼 **집계(`GROUP BY`)가 필요한 데이터**를  
JOIN으로 한 번에 가져올 경우:

- 쿼리 자체가 복잡해지고
- 인덱스 활용도가 떨어질 가능성이 있으며
- 불필요한 중복 데이터 전송이 발생한다

1:N:M 관계를 한 번에 JOIN하면  
애플리케이션 단에서 중복 데이터를 제거하는 로직 또한 복잡해진다고 판단했습니다.

그래서 복잡한 JOIN 대신  
쿼리를 **목록 / 타입 / 카운트**로 분리해 실행하고,  
애플리케이션 메모리에서 조립하는 **Application-side Join 방식**을 선택했습니다.

이로써 쿼리 복잡도는 낮추면서도  
N + 1 대비 성능을 효과적으로 개선할 수 있었습니다.

---

## 조회 전략 비교: JOIN vs Application-side Join vs Hibernate Batch Fetching

아래 비교는 특정 ORM 사용 여부와 관계없이,
데이터를 어디에서 결합하고 쿼리를 누가 제어하는지에 따른
조회 전략 관점에서 정리한 내용입니다.

| 구분 | JOIN | Application-side Join (Bulk Query) | Hibernate Batch Fetching |
|------|------|------------------------------------|---------------------------|
| 쿼리 실행 방식 | 단일 쿼리 | 여러 개의 Bulk Query | Lazy Loading 시 프록시 초기화 과정에서 묶어서 조회 |
| 쿼리 수 | 1 | 고정 (설계에 따라 2~3) | 상황에 따라 달라짐 |
| 중복 데이터 | 발생 가능 (1:N, 1:M) | 없음 | 없음 |
| 쿼리 복잡도 | 높아질 수 있음 | 낮음 | 낮음 |
| 집계 처리 (`GROUP BY`) | 복잡 | 명확 | 제한적 |
| 제어 주체 | DB | 애플리케이션 | ORM(Hibernate) |
| 사용 시점 | 단순 관계 조회 | 복잡한 관계 + 성능 제어 필요 시 | ORM 기반 개발 시 |

※ 본 글에서 언급하는 Application-side Join은 Hibernate의 `batch_fetch_size` 옵션과는 다른 개념으로,  
**IN 절 기반의 Bulk Query로 데이터를 명시적으로 조회한 뒤 애플리케이션 메모리에서 관계를 조립하는 방식**을 의미합니다.

---

## 마무리

이번 경험을 통해 N + 1 문제는 단순히 ORM의 문제가 아니라,  
**조회 패턴과 코드 재사용 전략이 바뀌는 시점에서 자연스럽게 드러나는 설계 문제**라는 점을 다시 한 번 느꼈습니다.

초기에는 생산성이 중요하지만, 데이터 규모가 커지는 시점에서는 조회 전략을 별도로 설계하는 것이 필수적이라는 교훈을 얻었습니다.
