---
title: "MySQL 테이블 ENUM vs VARCHAR vs INT"
description: >-
  개발 공부 때는 DB를 설계할 때 ENUM을 자주 사용했습니다. <br>
  하지만 실무에서는 왜 VARCHAR나 INT가 더 많이 사용될까요? <br>
  ENUM의 장단점, 운영 시 위험성, 세 방식의 매핑 구조를 DB 모델링 관점에서 정리한 글입니다.
author: inttype
date: 2025-12-10 23:22:00 +0900
categories: [Database, MySQL, Modeling]
tags: [db, mysql, mariadb, enum, varchar, int, schema, modeling, erd]
pin: false
---

> ⚠️ 본 글의 내용은 MySQL(MariaDB) 기준으로 작성되었습니다.  
> 다른 DBMS(PostgreSQL, Oracle 등)에서는 ENUM의 동작 방식이 다를 수 있습니다.

DB 테이블을 설계하다 보면 속성을 **ENUM, VARCHAR, INT 중 어떤 것으로 정의할지** 고민하게 됩니다.  
개발 공부 단계에서는 ENUM을 자주 사용했지만, 실무를 경험하면서 생각이 많이 변했습니다.

이 글에서는 **개발 공부할 때 ENUM을 자주 사용했던 이유 → 실무에서 느낀 ENUM의 불편함 → 실제 매핑 구조 → 어떤 선택을 하게 되었는지**  이 흐름으로 정리해보려고 합니다.

---

## 개발 공부 단계에서는 왜 ENUM을 자주 사용했을까?

처음 DB를 배울 때는 ENUM이 매우 매력적으로 보였습니다.

- 값이 명확함  
- 허용되는 값이 DB 차원에서 강제됨  
- 오타나 잘못된 값 입력 방지  
- 비즈니스 상태값을 선언적으로 표현 가능  

그렇기 때문에 **“상태값은 ENUM이 가장 깔끔하다”**고 생각했고, 실제로도 자주 사용했었습니다.

하지만 실무에서는 이야기가 조금 달랐습니다.

---

## ENUM / VARCHAR / INT 장단점 비교

| 타입 | 장점 | 단점 |
|------|------|-------|
| **ENUM** | - 값이 DB에서 강제됨<br>- 잘못된 데이터 입력 방지<br>- 저장 공간 효율적 | - 값 추가·변경 시 ALTER TABLE 필요<br>- 운영 중 스키마 변경 위험(metadata lock)<br>- 앱/배포와 버전 관리 필요 |
| **VARCHAR** | - 값 추가 자유롭고 스키마 변경 불필요<br>- 사람이 읽기 쉬움 | - 오타 발생 위험<br>- 유효성 검증을 애플리케이션에서 처리해야 함<br>- 저장 공간이 ENUM보다 큼 |
| **INT** | - 확장성 최고<br>- 값 추가해도 DB 변경 필요 없음<br>- 인덱스 효율이 좋아 성능 우수 | - 숫자만으로 의미 파악 어려움<br>- 매핑(enum/코드 테이블) 필요<br>- 코드/DB 불일치 위험 |

👉 요약  
- ENUM은 명확하지만 변경에 취약  
- VARCHAR는 유연하지만 검증 책임이 Application으로 이동  
- INT는 확장성 최고지만 관리해야 할 매핑이 늘어남  

---

## 실무에서 ENUM을 사용하기 어려운 이유

실무에서 ENUM을 사용하기 어려운 이유는 단 하나입니다.

> **새로운 값을 추가하기 어렵다. (ALTER 필요)**

예를 들어 ENUM이 아래처럼 정의되어 있다고 가정해 보면

```
ENUM('ACTIVE', 'INACTIVE')
```

여기에 `DORMANT`를 추가하고 싶다면?

```
ALTER TABLE user 
MODIFY status ENUM('ACTIVE', 'INACTIVE', 'DORMANT');
```

이 작업은 스키마 변경이며, 운영 중에는 치명적인 문제가 될 수 있습니다.

---

## 운영 환경에서 스키마 변경은 위험하다

- metadata lock 발생 가능  
- INSERT / UPDATE 지연  
- 트래픽이 많을수록 장애 위험 증가  
- 배포 일정과 묶임  
- 롤백 또한 쉽지 않음  

개인 프로젝트에서는 큰 문제가 아니지만, **실제 서비스에서는 매우 신중해야 하는 작업**입니다. <br>
(운영 중인 서비스의 스키마를 잘못 건드리면 주니어는 웁니다... 물론 주니어가 DB를 작업하는 일은 없을 수도 있지만 저는 해야합니다...)

---

## ENUM / VARCHAR / INT 실제 매핑 구조

## 1) ENUM 사용 구조

### ENUM은 DB에서 값을 직접 강제합니다.

```
┌──────────────┐
│ USER TABLE   │
│──────────────│
│ status: ENUM │ ← DB 차원에서 값 제한
└──────────────┘
```

### ENUM 값:
- ACTIVE  
- INACTIVE  
- DORMANT  

### 동작 방식:
- Application → 문자열 전달  
- DB → ENUM 목록에 없는 문자열이면 거부  

### 특징:
- 장점: 잘못된 데이터가 들어가기 어려움  
- 단점: 값 추가 시 반드시 ALTER 필요(운영 리스크 높음)  

---

## 2) VARCHAR 사용 구조

VARCHAR는 문자열을 그대로 저장하고  
유효성 검증은 Application(enum)이 담당합니다.

```
Application Enum ──(문자열 변환)──> DB VARCHAR 저장
```

### 예시  
Application : Status.ACTIVE  
DB  : "ACTIVE"

### 데이터 흐름:

```
Application enum → "ACTIVE" → DB 저장
```

### 특징:
- 장점: 새로운 값 추가해도 DB 스키마 변경 필요 없음  
- 단점: 오타 입력 가능 → Application에서 강제 필요  

---

## 3) INT + Enum 매핑 구조  
(대규모 서비스에서 가장 일반적)

DB에는 숫자만 저장하고  
해당 숫자의 의미는 Application 또는 코드 테이블이 관리합니다.

### ERD 구조(텍스트)

```
USER(status INT) ─────┐
                      └── STATUS_CODE TABLE
                           id (INT)
                           name (VARCHAR)
                           description (VARCHAR)
```

### STATUS_CODE 예시

```
1 | ACTIVE   | 정상 회원
2 | INACTIVE | 휴면 회원
3 | DORMANT  | 장기 미접속
```

### 애플리케이션 enum 매핑

```
enum Status {
  ACTIVE(1),
  INACTIVE(2),
  DORMANT(3)
}
```

### 데이터 흐름:

```
Application enum → 숫자(1) → DB 저장
DB 숫자(1) → enum(Status.ACTIVE)
```

### 특징:
- 장점: 확장성 최고, 값 변경·추가 자유로움  
- 단점: 매핑 관리 필요(복잡도 증가)  

---

## 4) 상태값 선택 기준 흐름도

```
상태값 정의 필요
        │
        ▼
상태가 자주 바뀌는가?
      │        │
     YES      NO
      │        │
  VARCHAR   대규모/성능 중요한가?
                     │
               YES          NO
                │           │
          INT + Enum 매핑   ENUM
```

---

## 그렇다면 ENUM은 왜 있는가?

ENUM은 과거 **DB 중심 설계(DB가 무결성을 책임지는 방식)**에서 매우 유용했습니다.

- 외부 시스템에서 잘못된 값이 들어오는 것을 DB 자체가 차단  
- SQL Tool에서 오타를 내도 DB에서 바로 검증  
- Application이 없어도 데이터 무결성이 유지됨  

그러나 최근에는:

- 서비스가 복잡해지고  
- MSA가 확산되고  
- Application이 유효성 검증을 책임지게 되면서  

**ENUM은 유지비용 대비 효용이 떨어지는 타입**이 되었다고 합니다. <br>
(구글링, AI를 통해 획득한 정보로 실제 현장에서는 다를 수도 있습니다!)

---

## 결론: 언제 어떤 타입을 선택할까?

- **ENUM** → 값이 절대 바뀌지 않음 + 단일 서비스 + DB 제약이 중요  
- **VARCHAR** → 상태 추가·변경이 잦고 확장이 중요한 경우  
- **INT + Enum 매핑** → 대규모 서비스, 성능·유지보수 중요  

---

## 내가 선택한 것은?

이번 프로젝트는 상태값이 **서비스 상황에 따라 확장될 가능성**이 컸습니다.
또한 규모가 크지 않아 INT 매핑까지는 필요 없었습니다.

그래서 저는 **VARCHAR**를 선택했습니다.

선택 이유:

- 스키마 변경 없이 상태 추가 가능  
- 기능 확장에 유연함  
- 현재 서비스 규모에서 INT 매핑은 오버엔지니어링  
- ENUM은 운영 위험이 있어 배제  

결론:  
**확장성 + 유연성 + 현재 프로젝트 규모**  
이 세 가지 기준으로 VARCHAR가 가장 적합하다고 생각했습니다.

---

## 마무리

DB 타입 선택은 단순한 기술 선택이 아니라  
**변경 가능성, 서비스 구조, 운영 리스크**를 고려해야 하는 설계적 결정이라고 생각합니다.

결국 중요한 것은 어떤 타입이 ‘더 좋다’가 아니라, 서비스의 특성에 맞는 타입을 선택하는 것이라고 생각합니다.

(이 글은 제가 공부하며 경험한 내용을 바탕으로 정리한 글이라 실제 환경과 다를 수 있습니다. 다른 의견이나 잘못된 부분이 있다면 편하게 알려주시면 감사하겠습니다!)