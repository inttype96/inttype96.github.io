---
title: "렌더링 방식 개선과 쿼리 최적화로 체감 성능 개선하기"
slug: optimize-rendering-and-api-performance
description: >-
  클라이언트 사이드 렌더링(CSR) 구조에서 발생하던 화면 공백 문제를
  스트리밍 기반 서버 사이드 렌더링(Streaming SSR)로 변경하고, REST API 쿼리 최적화를 통해
  응답 시간을 개선한 경험을 정리했습니다.
author: inttype
date: 2026-01-05 15:00:00 +0900
categories: [Development, Troubleshooting]
tags: [csr, ssr, streaming-ssr, performance, optimization, sveltekit, sql]
pin: false
media_subpath: '/assets/img/posts/2026-01-05-010-optimize-rendering-and-api-performance'
---

기존에 진행하던 프로젝트와는 별도로  
다른 프로젝트를 지원하게 되면서 일부 페이지를 개선하게 되었습니다.

그 과정에서 **사용자가 체감할 정도로 로딩이 지연되는 페이지**를 확인했고,  
해당 페이지를 분석하면서 렌더링 방식과 서버 구조 전반을 다시 살펴보게 되었습니다.

---

## 1. 문제 상황: 숫자보다 더 느리게 느껴졌던 화면

문제가 되었던 페이지는 REST API 응답 시간이 약 **1.05초**로,
데이터 로딩 단계에서 지연이 발생하고 있었습니다.

문제는 단순히 API가 느린 것에 그치지 않았습니다.  
페이지 구현 방식이 **클라이언트 사이드 렌더링(CSR)** 이었기 때문에,  
사용자가 페이지에 진입한 직후 약 1초 동안  
**“데이터가 없습니다”라는 문구가 그대로 노출**되고 있었습니다.

로딩 중이라는 안내나 스피너가 없었기 때문에  
사용자 입장에서는 데이터가 없는 것인지,  
아니면 데이터를 불러오는 중인지 구분하기 어려운 상황이었습니다.

Nielsen Norman Group(NNG)의 UX 연구에 따르면[^1],
사용자는 **1초를 넘기기 시작하면 시스템 지연을 인식하기 시작**한다고 설명하고 있습니다.

해당 페이지는 CSR 구조와 별도의 로딩 안내나 스피너가 없었기 때문에
API 응답을 기다리는 동안 빈 상태 메시지를 노출하고 있었고,  
그 결과, 사용자는 실제 데이터를 확인하기까지  
**CSR 구조와 API 지연이 누적된 약 2초 이상의 대기 시간**을 경험하고 있었습니다.


---

## 2. 기존 구조: CSR이 만들어낸 1초 공백

기존 CSR 구조의 흐름은 다음과 같았습니다.

```
페이지 진입
→ HTML 다운로드
→ JS 번들 로드 및 실행
→ onMount 실행
→ API 요청 (여기서 대기 발생)
→ 데이터 수신 후 화면 렌더링
```

### 핵심 문제

- API 요청이 **JS 실행 이후에야 시작됨**
- 네트워크 지연과 렌더링 지연이 **직렬(Waterfall)** 구조로 누적
- 사용자에게는 **의미 없는 초기 UI**가 그대로 노출됨

결과적으로,  
“화면이 먼저 뜬 뒤에 데이터를 가지러 가는 구조”가  
체감 성능을 떨어뜨리고 있었습니다.

---

## 3. 단순 SSR의 한계

CSR 문제를 해결하기 위해 **서버 사이드 렌더링(SSR)** 방식도 검토했습니다.
(여기서 SSR은 데이터를 모두 준비한 뒤 HTML을 한 번에 전달하는 전통적인 SSR 방식을 의미합니다.)

SSR의 흐름은 다음과 같습니다.
```
페이지 요청
→ 서버에서 API 호출
→ 데이터 응답 대기
→ 완성된 HTML 생성
→ 브라우저 전달
```

CSR에서 발생하던 빈 화면 문제는 해결할 수 있었지만,  
REST API 응답이 느린 상황에서는  
페이지 전환 자체가 **약 1초 이상 멈춘 것처럼 느껴지는 문제**가 발생했습니다.

즉, 렌더링 위치만 옮겼을 뿐  
**사용자가 기다려야 한다는 UX 구조 자체는 크게 달라지지 않았습니다.**

---

## 4. 최종 선택: Streaming SSR

문제를 근본적으로 해결하기 위해  
**스트리밍 기반 서버 사이드 렌더링(Streaming SSR)** 방식으로 구조를 변경했습니다.

Streaming SSR의 핵심은 다음 두 가지입니다.

1. **데이터 로딩과 화면 렌더링을 병렬로 처리**
2. **완성될 때까지 기다리지 않고, 화면을 먼저 전달**

### 변경된 흐름
```
페이지 요청
→ 서버에서 즉시 API 호출
→ 동시에 HTML Skeleton 전송 (약 25ms)
→ 브라우저는 즉시 화면 전환
→ 데이터 준비 완료 시 스트리밍으로 주입
```

이 구조로 변경하면서  
페이지 전환은 즉각적으로 이루어졌고,  
데이터는 로딩 UI 영역에 자연스럽게 채워지게 되었습니다.

또한 `"데이터를 불러오는 중입니다"`와 같은 명확한 로딩 문구를 추가해,  
사용자가 현재 상태를 오해하지 않도록 UX를 개선했습니다.

---

## 5. 렌더링 방식 한눈에 비교

| 구분 | CSR | (Traditional) SSR | Streaming SSR |
|---|---|---|---|
| 렌더링 주체 | 브라우저 | 서버 | 서버 + 브라우저 |
| 데이터 요청 시점 | JS 실행 이후 | 페이지 요청 시 | 페이지 요청 즉시 |
| 초기 화면 | 빈 UI | 대기 화면 | Skeleton |
| 화면 전환 체감 | 느림 | 답답함 | 즉각적 |
| API 요청 위치 | 브라우저 | 서버 | 서버 |
| UX 특성 | 공백 체감 큼 | 대기 체감 큼 | 대기 거의 없음 |

**요약**
- CSR: 화면은 빨리 뜨지만 데이터가 늦게 도착합니다.
- SSR: 데이터는 먼저 오지만 화면 전환이 늦습니다.
- Streaming SSR: 화면과 데이터를 동시에 처리합니다.

---

## 6. 하지만 진짜 병목은 서버에 있었습니다

렌더링 방식을 개선하면서  
사용자가 로딩을 인지하는 시간은 줄었지만,  
REST API 자체의 응답 시간 **1.05초** 문제는 그대로 남아 있었습니다.

서버 코드를 분석한 결과 다음과 같은 문제점이 확인되었습니다.

### 기존 서버 코드의 문제점

1. **불필요한 트랜잭션 사용**
   - 단순 조회(SELECT)에도 트랜잭션 사용
2. **과도한 DB 왕복**
   - 사용자 확인 → ID 조회 → 리스트 조회 (총 3회)
3. **Fast Path / Slow Path 구분 없음**
   - 대부분의 요청이 동일한 비용으로 처리됨

이 문제를 해결하기 위해  
쿼리 구조 자체를 개선하기로 했습니다.

---

## 7. 쿼리 구조 개선 전략과 결과

### 적용한 개선 포인트

- JOIN을 활용해 **DB 왕복 3회 → 1회**
- 읽기 로직에서 **트랜잭션 제거**
- 대부분의 요청을 먼저 처리하는 **Fast Path 도입**

### 성능 결과
```
기존: 1.05초 (1050ms)
개선 후: 25ms

약 42배 성능 개선
```

| 구분 | 실행 결과 |
|---|---|
| **최적화 전** | ![Before Optimization](001.before-optimization.png) |
| **최적화 후** | ![After Optimization](002.after-optimization.png) |

렌더링 구조 개선과 서버 쿼리 최적화가 함께 적용되면서,  
로딩 스피너조차 거의 보이지 않는 수준의 응답 속도를 확보할 수 있었습니다.

---

## 8. 그렇다면 CSR 방식을 그대로 유지해도 되지 않았을까?

이 지점에서 한 가지 의문이 들 수 있습니다.

> “근본적인 문제는 REST API 응답 시간이 느렸던 것이라면,  
> CSR 방식을 유지한 채 로딩 스피너나 안내 문구만 추가해도  
> 충분하지 않았을까?”

실제로 기존 CSR 구조에서도  
`로딩 중입니다`와 같은 문구나 스피너를 추가했다면  
사용자가 현재 상태를 오해하는 문제는 어느 정도 완화할 수 있었을 것입니다.

하지만 CSR 방식에서는 구조적인 한계가 여전히 남아 있었습니다.

CSR 구조에서는 API 요청이  
클라이언트 자바스크립트가 로드되고 실행된 이후에야 시작되기 때문에,
네트워크 지연과 렌더링 지연이 자연스럽게 누적되는 흐름을 가지게 됩니다.

즉, 로딩 UI를 추가하는 방식은  
“기다리는 동안 무엇을 보여줄 것인가”에 대한 개선일 뿐,  
“언제 데이터를 요청하고, 언제 화면을 전달할 것인가”라는  
구조적인 문제를 해결하지는 못합니다.

이번 개선에서는 단순히 사용자 혼란을 줄이는 것을 넘어서,
데이터 요청 시점과 화면 전달 시점을 분리하고
페이지 전환 자체를 즉각적으로 느낄 수 있도록
렌더링 구조를 재설계하는 방향을 선택했습니다.

그 결과, 같은 REST API 응답 시간을 가지더라도
사용자가 페이지 전환 과정에서 느끼는 대기 방식과
전체적인 이용 경험은 달라질 수 있음을 확인할 수 있었습니다.

---

## 9. 마무리

이번 경험을 통해 다시 한 번 느낀 점은,
**언제 데이터를 요청하고, 그 과정에서 어떤 화면을 사용자에게 보여주느냐에 따라
같은 성능 조건에서도 사용자가 인식하는 경험은 달라질 수 있다는 점이었습니다.**

- 스트리밍 기반 서버 사이드 렌더링(Streaming SSR)을 통해
  API 응답을 기다리는 동안의 화면 전달 방식과 UX 흐름을 개선할 수 있었고
- REST API 리팩토링을 통해 응답 시간 자체도 함께 개선할 수 있었습니다.
- 두 가지를 함께 적용했을 때 비로소 사용자 경험 관점에서 의미 있는 개선이 이루어졌습니다.

단순히 속도를 빠르게 만드는 데서 그친 것이 아니라,  
**렌더링 흐름과 서버 구조를 각각 분리해 바라보고 다시 설계해본 경험**으로 남은 트러블슈팅이었습니다.

---

### 참고
[^1]: Nielsen Norman Group,  
    [Response Times: The 3 Important Limits](https://www.nngroup.com/articles/response-times-3-important-limits)